<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2021-04-30 Fri 16:59 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cs4231</title>
<meta name="author" content="Tan Yee Jian" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Cs4231</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org29e4cc8">1. Arrows</a></li>
<li><a href="#org287a316">2. Lecture 5 Global Snapshot</a>
<ul>
<li><a href="#org946204f">2.1. Definitions</a>
<ul>
<li><a href="#orgf0703e1">2.1.1. Global snapshot</a></li>
<li><a href="#org50716ba">2.1.2. Consistent global snapshot</a></li>
</ul>
</li>
<li><a href="#org02bd957">2.2. Chandy &amp; Lamport&rsquo;s protocal for taking snapshots</a></li>
</ul>
</li>
<li><a href="#org0ffa8f5">3. Lecture 6 Message Ordering</a>
<ul>
<li><a href="#orgaa7206a">3.1. Definitions</a>
<ul>
<li><a href="#orgac00a7e">3.1.1. Fully Asynchronous</a></li>
<li><a href="#orgcb52953">3.1.2. FIFO</a></li>
<li><a href="#orgdb3469b">3.1.3. Causally Ordered</a></li>
<li><a href="#org2554385">3.1.4. Synchronous Ordered</a></li>
</ul>
</li>
<li><a href="#org51221f4">3.2. Algorithm to ensure Causal Ordering</a>
<ul>
<li><a href="#org8ac2f23">3.2.1. Core Idea</a></li>
<li><a href="#org8b00946">3.2.2. Why does it work?</a></li>
<li><a href="#org105f711">3.2.3. Can we improve it?</a></li>
</ul>
</li>
<li><a href="#org9542e01">3.3. Skeen&rsquo;s Algorithm for Broadcast Ordering</a>
<ul>
<li><a href="#org4487841">3.3.1. Core Idea</a></li>
<li><a href="#org7d2dc57">3.3.2. Summary</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org35ba0b5">4. Lecture 7 Leader Election</a>
<ul>
<li><a href="#orgf083f47">4.1. Chang-Roberts Algorithm for Leader Election</a>
<ul>
<li><a href="#org09f5d52">4.1.1. Setting</a></li>
<li><a href="#orgdce9ecc">4.1.2. Algorithm</a></li>
<li><a href="#org029a15b">4.1.3. Complexity</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#orgb2e472f">5. Lecture 8 Consensus</a>
<ul>
<li><a href="#org6cd73b2">5.1. Timing Models</a>
<ul>
<li><a href="#orga21b6f8">5.1.1. Synchronous</a></li>
</ul>
</li>
<li><a href="#orgfac1d1a">5.2. Goals/Conditions for consensus</a>
<ul>
<li><a href="#orgacebe19">5.2.1. Termination</a></li>
<li><a href="#org2bf53f8">5.2.2. Agreement</a></li>
<li><a href="#orga244bb4">5.2.3. Validity</a></li>
</ul>
</li>
<li><a href="#org0b08225">5.3. Version 0: No failure (regardless of timing model)</a>
<ul>
<li><a href="#org660bdac">5.3.1. Algorithm</a></li>
<li><a href="#org9bb6d8a">5.3.2. When does it work?</a></li>
</ul>
</li>
<li><a href="#orge1cda8c">5.4. Version 1: (Synchronous) Node crash failures</a>
<ul>
<li><a href="#org3d11d8a">5.4.1. Setup</a></li>
<li><a href="#org0c78d2c">5.4.2. Intuition</a></li>
<li><a href="#org4385f5f">5.4.3. Protocol</a></li>
<li><a href="#org5b538c1">5.4.4. Lower bound is (Omega(f))</a></li>
</ul>
</li>
<li><a href="#org771dbef">5.5. Version 2: (Synchronous) Link Failure</a>
<ul>
<li><a href="#orgfac85e3">5.5.1. Setup</a></li>
<li><a href="#org0cbbcc8">5.5.2. Goal 1: Termination, Agreement, Validity</a></li>
<li><a href="#org1b03367">5.5.3. Goal 2: T, A, Weakened Validity</a></li>
<li><a href="#orgee1d6c7">5.5.4. Goal 3: T, Limited Agreement, Weakened Validity</a></li>
</ul>
</li>
<li><a href="#org367046e">5.6. Version 3: (Asynchronous) Node crash failures</a>
<ul>
<li><a href="#orgbc04526">5.6.1. Setup</a></li>
<li><a href="#org9becade">5.6.2. Fischer-Lynch-Paterson (FLP) Impossibility Theorem</a></li>
</ul>
</li>
<li><a href="#org40785d1">5.7. Version 4: (Synchronous) Byzantine Failures</a>
<ul>
<li><a href="#orgebda40e">5.7.1. Failure Model</a></li>
<li><a href="#org4c3775c">5.7.2. Modified goals - everything only applies to non-faulty nodes</a></li>
<li><a href="#orgea28da3">5.7.3. A simple (unsuccessful) attempt</a></li>
<li><a href="#org8d3a11e">5.7.4. Theorem: Byzantine Consensus Threshold</a></li>
<li><a href="#orgadd4419">5.7.5. A protocol for # nodes n &gt;= 4f+1</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-org29e4cc8" class="outline-2">
<h2 id="org29e4cc8"><span class="section-number-2">1</span> Arrows</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>\(a\prec b\) is process order.</li>
<li>\(a\to b\) is happen-before order: the logical clock value is less than, iff
there is a directed path. Clearly \(a\prec b\implies a\to b\).</li>
<li>\(a\leadsto b\) is the send-receive order.</li>
</ul>
</div>
</div>
<div id="outline-container-org287a316" class="outline-2">
<h2 id="org287a316"><span class="section-number-2">2</span> Lecture 5 Global Snapshot</h2>
<div class="outline-text-2" id="text-2">
<p>
Assumption: channels are FIFO. If not, it is discussed in Message Ordering
lecture
</p>
</div>
<div id="outline-container-org946204f" class="outline-3">
<h3 id="org946204f"><span class="section-number-3">2.1</span> Definitions</h3>
<div class="outline-text-3" id="text-2-1">
</div>
<div id="outline-container-orgf0703e1" class="outline-4">
<h4 id="orgf0703e1"><span class="section-number-4">2.1.1</span> Global snapshot</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
A set of events <code>E</code> such that for any event <code>e</code> in <code>E</code>, if \(f\prec e\), then
\(f\in E\).
</p>
</div>
</div>
<div id="outline-container-org50716ba" class="outline-4">
<h4 id="org50716ba"><span class="section-number-4">2.1.2</span> Consistent global snapshot</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
A global snapshot where if \(e_1\) send, \(e_2\) receive, \(e_2\) in then \(e_1\) must be in.
</p>
</div>
</div>
</div>
<div id="outline-container-org02bd957" class="outline-3">
<h3 id="org02bd957"><span class="section-number-3">2.2</span> Chandy &amp; Lamport&rsquo;s protocal for taking snapshots</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>Key idea:
<ol class="org-ol">
<li>after a process takes a snapshot, it orders others to stop via a message</li>
<li>If they already took a snapshot before the order arrives, then capture all
message till the order (these are the on-the-fly messages)</li>
<li>Otherwise once they receive the order, stop. (otherwise will receive stuff
which sender does not include)</li>
</ol></li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org0ffa8f5" class="outline-2">
<h2 id="org0ffa8f5"><span class="section-number-2">3</span> Lecture 6 Message Ordering</h2>
<div class="outline-text-2" id="text-3">
<p>
We still assume FIFO (except for fully async order) for inter-process channels.
</p>
</div>
<div id="outline-container-orgaa7206a" class="outline-3">
<h3 id="orgaa7206a"><span class="section-number-3">3.1</span> Definitions</h3>
<div class="outline-text-3" id="text-3-1">
</div>
<div id="outline-container-orgac00a7e" class="outline-4">
<h4 id="orgac00a7e"><span class="section-number-4">3.1.1</span> Fully Asynchronous</h4>
<div class="outline-text-4" id="text-3-1-1">
<p>
No restriction.
</p>
</div>
</div>
<div id="outline-container-orgcb52953" class="outline-4">
<h4 id="orgcb52953"><span class="section-number-4">3.1.2</span> FIFO</h4>
<div class="outline-text-4" id="text-3-1-2">
<p>
Messages \(s_1,s_2\) are sent from i to j. Then \(\neg(s_2\prec s_1)\).
</p>
</div>
</div>
<div id="outline-container-orgdb3469b" class="outline-4">
<h4 id="orgdb3469b"><span class="section-number-4">3.1.3</span> Causally Ordered</h4>
<div class="outline-text-4" id="text-3-1-3">
<p>
If \(s_1\) happen before \(s_2\), \(r_1, r_2\) on the same process, then \(r_1\prec
r_2\).
</p>
</div>
</div>
<div id="outline-container-org2554385" class="outline-4">
<h4 id="org2554385"><span class="section-number-4">3.1.4</span> Synchronous Ordered</h4>
<div class="outline-text-4" id="text-3-1-4">
<p>
Diagram can be redrawn into vertical, respecting happen-before, process and
send-receive order.
</p>
</div>
</div>
</div>
<div id="outline-container-org51221f4" class="outline-3">
<h3 id="org51221f4"><span class="section-number-3">3.2</span> Algorithm to ensure Causal Ordering</h3>
<div class="outline-text-3" id="text-3-2">
</div>
<div id="outline-container-org8ac2f23" class="outline-4">
<h4 id="org8ac2f23"><span class="section-number-4">3.2.1</span> Core Idea</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
When a process sends a message, attach also every message you have seen or sent
so far.
</p>
</div>
</div>
<div id="outline-container-org8b00946" class="outline-4">
<h4 id="org8b00946"><span class="section-number-4">3.2.2</span> Why does it work?</h4>
<div class="outline-text-4" id="text-3-2-2">
<ul class="org-ul">
<li>Recall causal ordering: if s1 happens before s2 (there is a directed path),
then r1 must before r2</li>
<li>If s1 and s2 are on the same process, then attaching all messages it has sent
will include s1 for the target process to see before s2</li>
<li>If not on the same process, then attaching all messages it has received will
include s1 for the target process to see before s2.</li>
</ul>
</div>
</div>
<div id="outline-container-org105f711" class="outline-4">
<h4 id="org105f711"><span class="section-number-4">3.2.3</span> Can we improve it?</h4>
<div class="outline-text-4" id="text-3-2-3">
<ul class="org-ul">
<li>Just include messages that are targeted at the receiving process.</li>
<li>Or number each message locally on the process. Instead of attaching all
messages, make the target wait until all processes&rsquo; intended message to it has
been delivered.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org9542e01" class="outline-3">
<h3 id="org9542e01"><span class="section-number-3">3.3</span> Skeen&rsquo;s Algorithm for Broadcast Ordering</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>An example is a chat group, sending messages to everyone</li>
<li>Everyone needs the same message number for the same msg</li>
</ul>
</div>
<div id="outline-container-org4487841" class="outline-4">
<h4 id="org4487841"><span class="section-number-4">3.3.1</span> Core Idea</h4>
<div class="outline-text-4" id="text-3-3-1">
<ol class="org-ol">
<li>First round - send message to everyone to save in the buffer. After saving,
each process replies the coordinator their current logical clock number.</li>
<li>Wait for all them to come back, and assign the message the largest logical
clock number.</li>
<li>Let everyone know the decided message number.</li>
</ol>
</div>
</div>
<div id="outline-container-org7d2dc57" class="outline-4">
<h4 id="org7d2dc57"><span class="section-number-4">3.3.2</span> Summary</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
It orders messages, not logical clock numbers. Each logical clock value run as
usual.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org35ba0b5" class="outline-2">
<h2 id="org35ba0b5"><span class="section-number-2">4</span> Lecture 7 Leader Election</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgf083f47" class="outline-3">
<h3 id="orgf083f47"><span class="section-number-3">4.1</span> Chang-Roberts Algorithm for Leader Election</h3>
<div class="outline-text-3" id="text-4-1">
</div>
<div id="outline-container-org09f5d52" class="outline-4">
<h4 id="org09f5d52"><span class="section-number-4">4.1.1</span> Setting</h4>
<div class="outline-text-4" id="text-4-1-1">
<p>
Given a ring of nodes that can only send messages clockwise, select a leader
</p>
</div>
</div>
<div id="outline-container-orgdce9ecc" class="outline-4">
<h4 id="orgdce9ecc"><span class="section-number-4">4.1.2</span> Algorithm</h4>
<div class="outline-text-4" id="text-4-1-2">
<ol class="org-ol">
<li>Sending: Every node send its number clockwise</li>
<li>Receiving: Every node relay the message (clockwise) if the value is bigger
than self.</li>
<li>If receive own id, then it is the leader</li>
</ol>
</div>
</div>
<div id="outline-container-org029a15b" class="outline-4">
<h4 id="org029a15b"><span class="section-number-4">4.1.3</span> Complexity</h4>
<div class="outline-text-4" id="text-4-1-3">
</div>
<ol class="org-ol">
<li><a id="org73caf87"></a>Message Complexity<br />
<div class="outline-text-5" id="text-4-1-3-1">
<p>
Number of messages sent
</p>
</div>
</li>
<li><a id="org13b9d35"></a>Best Case<br />
<div class="outline-text-5" id="text-4-1-3-2">
<p>
Condition: sorted in clockwise ascending
1+&#x2026;+1+n = 2n-1
</p>
</div>
</li>
<li><a id="org820b8bc"></a>Worst case<br />
<div class="outline-text-5" id="text-4-1-3-3">
<p>
Condition: sorted in clockwise descending
1 + 2 + &#x2026; + n = n(n+1)/2
</p>
</div>
</li>
<li><a id="org3a59af7"></a>Average case?<br /></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgb2e472f" class="outline-2">
<h2 id="orgb2e472f"><span class="section-number-2">5</span> Lecture 8 Consensus</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org6cd73b2" class="outline-3">
<h3 id="org6cd73b2"><span class="section-number-3">5.1</span> Timing Models</h3>
<div class="outline-text-3" id="text-5-1">
</div>
<div id="outline-container-orga21b6f8" class="outline-4">
<h4 id="orga21b6f8"><span class="section-number-4">5.1.1</span> Synchronous</h4>
<div class="outline-text-4" id="text-5-1-1">
<ul class="org-ul">
<li>Bounded amount of time to do processing (generate output msg, process input
msg)</li>
<li>and bounded amount of time to send messages</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-orgfac1d1a" class="outline-3">
<h3 id="orgfac1d1a"><span class="section-number-3">5.2</span> Goals/Conditions for consensus</h3>
<div class="outline-text-3" id="text-5-2">
</div>
<div id="outline-container-orgacebe19" class="outline-4">
<h4 id="orgacebe19"><span class="section-number-4">5.2.1</span> Termination</h4>
</div>
<div id="outline-container-org2bf53f8" class="outline-4">
<h4 id="org2bf53f8"><span class="section-number-4">5.2.2</span> Agreement</h4>
</div>
<div id="outline-container-orga244bb4" class="outline-4">
<h4 id="orga244bb4"><span class="section-number-4">5.2.3</span> Validity</h4>
</div>
</div>
<div id="outline-container-org0b08225" class="outline-3">
<h3 id="org0b08225"><span class="section-number-3">5.3</span> Version 0: No failure (regardless of timing model)</h3>
<div class="outline-text-3" id="text-5-3">
</div>
<div id="outline-container-org660bdac" class="outline-4">
<h4 id="org660bdac"><span class="section-number-4">5.3.1</span> Algorithm</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
For any process:
</p>
<ol class="org-ol">
<li>Keep broadcasting own value</li>
<li>Once confident have all messages (due to known ub), run a deterministic
algorithm on all values (eg. max/min)</li>
</ol>
</div>
</div>
<div id="outline-container-org9bb6d8a" class="outline-4">
<h4 id="org9bb6d8a"><span class="section-number-4">5.3.2</span> When does it work?</h4>
<div class="outline-text-4" id="text-5-3-2">
</div>
<ol class="org-ol">
<li><a id="orgb0fecde"></a><span class="todo TODO">TODO</span> Synchronous<br /></li>
<li><a id="org31532bc"></a><span class="todo TODO">TODO</span> Async<br /></li>
</ol>
</div>
</div>
<div id="outline-container-orge1cda8c" class="outline-3">
<h3 id="orge1cda8c"><span class="section-number-3">5.4</span> Version 1: (Synchronous) Node crash failures</h3>
<div class="outline-text-3" id="text-5-4">
</div>
<div id="outline-container-org3d11d8a" class="outline-4">
<h4 id="org3d11d8a"><span class="section-number-4">5.4.1</span> Setup</h4>
<div class="outline-text-4" id="text-5-4-1">
<ul class="org-ul">
<li>Synchronous, all nodes have bounded processing time, all message has bounded
delay</li>
<li>Crash failure - crashes forever. On a &ldquo;round&rdquo; that it crashes, broadcast might
not happen/not be complete.</li>
</ul>
</div>
</div>
<div id="outline-container-org0c78d2c" class="outline-4">
<h4 id="org0c78d2c"><span class="section-number-4">5.4.2</span> Intuition</h4>
<div class="outline-text-4" id="text-5-4-2">
<ul class="org-ul">
<li>We use rounds to gain information on crash: if no reply, then crashed.</li>
<li>How to delineate rounds: let t1 be delay to generate output, t2 for message
propagation, t3 to process input, then each round is simply <code>t1+t2+t3</code> long.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org90f0c12"></a>Suppose we don&rsquo;t have accurate clock<br />
<div class="outline-text-5" id="text-5-4-2-1">
<ul class="org-ul">
<li>Claim: every clock should be some constant multiple of other clocks.</li>
<li>Consider a case where clock = 2x accurate clock.
<ul class="org-ul">
<li>Attempt 1: everyone set round duration to <code>2(t1+t2+t3)</code>. The process with
faster clock will advance rounds faster. Then every process that receives a
new message starts a new round. But what if a round starts before a process
has time to process its received message?</li>
<li>Attempt 2: We provide the offset, making the round duration
<code>2(t1+t2+t3+(t1+t2))</code>, the new offset tolerates the message delay(process
output, send msg) to the &ldquo;latest&rdquo; node.</li>
</ul></li>
</ul>
</div>
</li>
</ol>
</div>
<div id="outline-container-org4385f5f" class="outline-4">
<h4 id="org4385f5f"><span class="section-number-4">5.4.3</span> Protocol</h4>
<div class="outline-text-4" id="text-5-4-3">
</div>
<ol class="org-ol">
<li><a id="orgb2e214e"></a>Intuition<br />
<div class="outline-text-5" id="text-5-4-3-1">
<ul class="org-ul">
<li>suppose there is no failure, we can just broadcast our message to everyone and conclude.</li>
<li>Since there can be a failure, we can <b>&ldquo;forward&rdquo;</b> all messages received in our broadcast.</li>
<li>What is left is to decide how many rounds are needed.</li>
</ul>
</div>
</li>
<li><a id="org0c53949"></a>Details<br />
<div class="outline-text-5" id="text-5-4-3-2">
<ol class="org-ol">
<li>Intialize the set <code>S:={my_input}</code>.</li>
<li>Broadcast S to everyone for <code>f+1</code> rounds (where f is number of node crashes
to tolerate)</li>
<li>Union S with all the sets received in this round, and repeat 2.</li>
</ol>
</div>
</li>
<li><a id="orgedf88d6"></a>Correctness<br />
<ol class="org-ol">
<li><a id="orgceae3b4"></a>Termination is obvious (f+1 rounds, bounded waiting)<br /></li>
<li><a id="org042daaa"></a>Validity is obvious (if everyone same input, S = {s} is singleton)<br /></li>
<li><a id="org12d1a2c"></a>Agreement<br />
<div class="outline-text-6" id="text-5-4-3-3-3">
<ol class="org-ol">
<li>Given f+1 rounds and f failure, there must be at least 1 round with no
failure. Call that the good round.</li>
<li>See that the good round must end with all nodes (that haven&rsquo;t crashed) with
the same set <code>S</code>.</li>
<li>After the good round, each nodes&rsquo;s <code>S</code> do not change anymore.</li>
<li>Then the deterministic function will choose the same value for all surviving
nodes.</li>
</ol>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-org5b538c1" class="outline-4">
<h4 id="org5b538c1"><span class="section-number-4">5.4.4</span> Lower bound is (Omega(f))</h4>
<div class="outline-text-4" id="text-5-4-4">
<ul class="org-ul">
<li>Statement: any deterministic algorithm that works (fulfills termination,
agreement, validity) must take at least f+1 rounds.</li>
<li>Proof is too hard (not in scope).</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org771dbef" class="outline-3">
<h3 id="org771dbef"><span class="section-number-3">5.5</span> Version 2: (Synchronous) Link Failure</h3>
<div class="outline-text-3" id="text-5-5">
</div>
<div id="outline-container-orgfac85e3" class="outline-4">
<h4 id="orgfac85e3"><span class="section-number-4">5.5.1</span> Setup</h4>
<div class="outline-text-4" id="text-5-5-1">
<ul class="org-ul">
<li>nodes do not fail</li>
<li>but the message channels (between any pair of processes) can fail arbitrarily
long (drop unbounded # of messages)</li>
</ul>
</div>
</div>
<div id="outline-container-org0cbbcc8" class="outline-4">
<h4 id="org0cbbcc8"><span class="section-number-4">5.5.2</span> Goal 1: Termination, Agreement, Validity</h4>
<div class="outline-text-4" id="text-5-5-2">
<ul class="org-ul">
<li>Termination: all nodes eventually decide</li>
<li>Agreement: all nodes settle on one same value</li>
<li>Validity: if all started as same value, must settle on that value.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org7d5a6f3"></a>There is no deterministic algorithm<br />
<div class="outline-text-5" id="text-5-5-2-1">
<ol class="org-ol">
<li><p>
Suppose there is one. Two processes with a eternally failing channel. Assume
both have input 1, then has to conclude with 1.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">process</th>
<th scope="col" class="org-right">input</th>
<th scope="col" class="org-right">conclusion</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
<li><p>
Suppose process B has input 0. To A, this is indistinguishable from B having
input 1 since they cannot communicate. Thus B will still conclude 1.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">process</th>
<th scope="col" class="org-right">input</th>
<th scope="col" class="org-left">conclusion</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">1</td>
<td class="org-left">1 (indistinguishable)</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">0</td>
<td class="org-left">1</td>
</tr>
</tbody>
</table></li>
<li><p>
By Agreement, B will conclude as 1 too, force by A&rsquo;s ignorant conclusion.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">process</th>
<th scope="col" class="org-right">input</th>
<th scope="col" class="org-left">conclusion</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">1</td>
<td class="org-left">1</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">0</td>
<td class="org-left">1 (Agreement)</td>
</tr>
</tbody>
</table></li>
<li><p>
Now suppose A has input 0 as well. To B, this is indistinguishable from A
having 1 (remember by 2, 3, A having 1 forces B to conclude 1) so it will
still conclude with 1.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">process</th>
<th scope="col" class="org-right">input</th>
<th scope="col" class="org-left">conclusion</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">0</td>
<td class="org-left">1</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">0</td>
<td class="org-left">1 (indistinguishable)</td>
</tr>
</tbody>
</table></li>
<li><p>
Then A will be forced to conclude with 1, violating Validity. Contradiction.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">process</th>
<th scope="col" class="org-right">input</th>
<th scope="col" class="org-left">conclusion</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-right">0</td>
<td class="org-left">1 (validity)</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-right">0</td>
<td class="org-left">1</td>
</tr>
</tbody>
</table></li>
</ol>
</div>
</li>
</ol>
</div>
<div id="outline-container-org1b03367" class="outline-4">
<h4 id="org1b03367"><span class="section-number-4">5.5.3</span> Goal 2: T, A, Weakened Validity</h4>
<div class="outline-text-4" id="text-5-5-3">
<ul class="org-ul">
<li>Since validity was violated just now, we try to weaken it. Is consensus
possible now?</li>
<li>If all start from 0, should settle on 0</li>
<li>If all start from 1, then must settle on 1 only if no message is lost</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org25753ac"></a>Still no deterministic algorithm.<br />
<div class="outline-text-5" id="text-5-5-3-1">
<ul class="org-ul">
<li>Lemma: if two processes start with 1, and one process&rsquo;s last message is lost,
none detects it. Then the one who lost, B, didn&rsquo;t know it lost, hence is
<b>indistinguishable</b> from nothing is lost and must settle on 1. By agreement, A
should settle on 1 as well.</li>
<li>Using the lemma above, we can still chain indistinguishability from 0, 0 to 1,
1 and force a contradiction (settle on 0, 0 given 1, 1, when all messages are
lost)</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgef76a21"></a>Proof of no deterministic algorithm<br />
<div class="outline-text-6" id="text-5-5-3-1-1">
<p>
Essentially the same as in the previous Goal, but start with 0,0. Achieve
contradiction not by validity (we weakened it thus would not be contradicted),
but consider an undetected loss of last message, which has to conclude with 1,1.
</p>
</div>
</li>
</ol>
</li>
</ol>
</div>
<div id="outline-container-orgee1d6c7" class="outline-4">
<h4 id="orgee1d6c7"><span class="section-number-4">5.5.4</span> Goal 3: T, Limited Agreement, Weakened Validity</h4>
<div class="outline-text-4" id="text-5-5-4">
<ul class="org-ul">
<li>Limited Agreement: all nodes decide on the same value with probability =
(1-\(\epsilon\))</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org5354d88"></a>The concept of adversary<br />
<div class="outline-text-5" id="text-5-5-4-1">
<p>
We imagine the message losses are not just random, but as bad as possible, as if
designed by an adversary to destroy our plans for consensus. Then we do a worst
case analysis against this adversary.
</p>
</div>
</li>
<li><a id="org708cbac"></a>Randomized Algorithm that works with error (1/r)<br />
<div class="outline-text-5" id="text-5-5-4-2">
<ol class="org-ol">
<li>Setup: We have processes P1, P2, etc.
<ul class="org-ul">
<li>All random choices not known by adversary beforehand.</li>
<li>Let the total number of rounds to be <code>r</code>.</li>
<li>Each process has an <b>input</b>, 0 or 1. Each process has a value called
<b>level</b>, initialized to 0.</li>
<li>P1 sets the a <b>bar</b> randomly between 1 and r, inclusive. Every process
tries to increment <b>level</b> so that they reach the <b>bar</b> over the <code>r</code>
rounds.</li>
</ul></li>
<li>Broadcast messages and receive messages for r rounds. Each message contain
<b>bar</b> (if you know it), <b>input</b>, and own <b>level</b>. Upon receive, update own
<b>level</b> to <code>l+1</code> if everyone is at least level <code>l</code>.</li>
<li>We can inductively show that every pair of levels must differ by at most one
at every round.</li>
<li>Once r rounds are over, decide on 1 IFF you know that everyone has input 1
AND you know bar (trivial for P1) AND level &gt;= bar.</li>
</ol>
</div>
<ol class="org-ol">
<li><a id="org69e62a7"></a>Analysis<br />
<ol class="org-ol">
<li><a id="orgf258ae0"></a>Termination (obvious by <code>r</code> rounds)<br /></li>
<li><a id="orgc489ad5"></a>Agreement with probability (1-1/r)<br />
<div class="outline-text-7" id="text-5-5-4-2-1-2">
<ul class="org-ul">
<li>Since not every process&rsquo;s <b>level</b> will reach <b>bar</b>, not everyone can decide</li>
</ul>
<p>
correctly (eg, should decide 1 but limited by insufficient level). We then
analyze what is the probability for these events.
</p>
<ul class="org-ul">
<li>Error only happens if P1 decide on 1 while P2 decide on 0 (WLOG).</li>
<li>Denote P1&rsquo;s level as L1, P2&rsquo;s level as L2.</li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org88ab826"></a>Scenario: One process decides 1, the other process decides 0<br />
<ol class="org-ol">
<li><a id="org5f81b88"></a>Case 1: P1 hears P2, but P2 never heard from P1 at all<br />
<div class="outline-text-9" id="text-5-5-4-2-1-2-1-1">
<ul class="org-ul">
<li><p>
Then P2 must have level 0 (L2 = 0). It never heard from P1 and does not know
bar, hence will conclude 0.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">process</th>
<th scope="col" class="org-left">level</th>
<th scope="col" class="org-left">decision</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">P1</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">P2</td>
<td class="org-left">0</td>
<td class="org-left">0</td>
</tr>
</tbody>
</table></li>
<li><p>
P1 hears P2 so must have level 1 (L1 = 1). To be an error case, it must
decide 1.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">process</th>
<th scope="col" class="org-right">level</th>
<th scope="col" class="org-right">decision</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">P1</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>

<tr>
<td class="org-left">P2</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>
</tbody>
</table></li>
<li>What do we know, now P1 decides 1? All conditions below must be fulfilled:
<ol class="org-ol">
<li>Knows bar (no new info, P1 set the bar)</li>
<li>All inputs are 1</li>
<li>1 &gt;= bar. Since bar is at least 1, bar = 1.</li>
</ol></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="org5c68d16"></a>Conclusion: only happens when bar = 1, probability = 1/r<br /></li>
</ol>
</li>
<li><a id="orga4ebb31"></a>Case 2: P2 hears P1, but P1 never heard from P2 at all<br />
<div class="outline-text-9" id="text-5-5-4-2-1-2-1-2">
<ul class="org-ul">
<li><p>
Then P1 must have level 0 (L1 = 0). It never heard from P2 and does not know
P2&rsquo;s input, hence will conclude 0.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">process</th>
<th scope="col" class="org-right">level</th>
<th scope="col" class="org-right">decision</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">P1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">P2</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
</tr>
</tbody>
</table></li>
<li><p>
P2 hears P1 so must have level 1 (L2 = 1). To be an error case, it must
decide 1.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">process</th>
<th scope="col" class="org-right">level</th>
<th scope="col" class="org-right">decision</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">P1</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
</tr>

<tr>
<td class="org-left">P2</td>
<td class="org-right">1</td>
<td class="org-right">1</td>
</tr>
</tbody>
</table></li>
<li>What do we know, now P2 decides 1? All conditions below must be fulfilled:
<ol class="org-ol">
<li>Knows bar (no new info, P2 heard from P1)</li>
<li>All inputs are 1</li>
<li>1 = L2 &gt;= bar. Since bar is at least 1, bar = 1.</li>
</ol></li>
</ul>
</div>
<ol class="org-ol">
<li><a id="orgcf2db62"></a>Conclusion: only happens when bar = 1, probability = 1/r<br /></li>
</ol>
</li>
<li><a id="orgddb9e25"></a>Case 3: P1 did not hear from P2 and vice versa<br />
<div class="outline-text-9" id="text-5-5-4-2-1-2-1-3">
<p>
This case would not cause error, since they will both conclude 0.
</p>
</div>
</li>
<li><a id="org3734d40"></a>Case 4: P1 heard from P2 and vice versa<br />
<div class="outline-text-9" id="text-5-5-4-2-1-2-1-4">
<ul class="org-ul">
<li>The only violatable condition before concluding 1, is that <code>level&lt;bar</code>.</li>
<li>Their <b>level</b> difference is at most one (by lemma).</li>
<li>Probability is <code>1/r</code>, when the <b>bar</b> is set to the maximum of the two.</li>
</ul>
</div>
</li>
</ol>
</li>
<li><a id="org5877861"></a>Conclusion: error probability is 1/r.<br /></li>
</ol>
</li>
<li><a id="orgecf5daa"></a>Weakened Validity<br />
<div class="outline-text-7" id="text-5-5-4-2-1-3">
<ul class="org-ul">
<li>suppose everyone starts with 0, no one can conclude 1 therefore everyone will
conclude 0.</li>
<li>suppose everyone starts with 1.
<ul class="org-ul">
<li>suppose no message lost, everyone will reach <b>bar</b> in <code>r</code> (\(r\ge bar\))
rounds. In fact, everyone will have <b>level</b> = <code>r</code>. Everyone will conclude 1.</li>
<li>suppose message lost, then can decide on anything.</li>
</ul></li>
</ul>
</div>
</li>
</ol>
</li>
</ol>
</li>
<li><a id="org56fe72f"></a>Error probability of 1/#rounds is a lower bound.<br />
<div class="outline-text-5" id="text-5-5-4-3">
<ul class="org-ul">
<li>proof can be found in Lynch.</li>
</ul>
</div>
</li>
</ol>
</div>
</div>
<div id="outline-container-org367046e" class="outline-3">
<h3 id="org367046e"><span class="section-number-3">5.6</span> Version 3: (Asynchronous) Node crash failures</h3>
<div class="outline-text-3" id="text-5-6">
</div>
<div id="outline-container-orgbc04526" class="outline-4">
<h4 id="orgbc04526"><span class="section-number-4">5.6.1</span> Setup</h4>
<div class="outline-text-4" id="text-5-6-1">
<ul class="org-ul">
<li>Nodes can crash (indefinitely), but channels are reliable</li>
<li>Asynchronous: message delay is unbounded</li>
<li>Impact: can no longer define a round</li>
</ul>
</div>
</div>
<div id="outline-container-org9becade" class="outline-4">
<h4 id="org9becade"><span class="section-number-4">5.6.2</span> Fischer-Lynch-Paterson (FLP) Impossibility Theorem</h4>
<div class="outline-text-4" id="text-5-6-2">
<p>
Statement: the distributed consensus problem under the asynchronous timing model
is impossible to solve, even with a <b>single</b> node crash failure.
</p>
<ul class="org-ul">
<li>Fundamental reason: the protocol is unable to accurately detect node failure.</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-org40785d1" class="outline-3">
<h3 id="org40785d1"><span class="section-number-3">5.7</span> Version 4: (Synchronous) Byzantine Failures</h3>
<div class="outline-text-3" id="text-5-7">
</div>
<div id="outline-container-orgebda40e" class="outline-4">
<h4 id="orgebda40e"><span class="section-number-4">5.7.1</span> Failure Model</h4>
<div class="outline-text-4" id="text-5-7-1">
<p>
Each node can &ldquo;lie&rdquo; about its input.
</p>
</div>
</div>
<div id="outline-container-org4c3775c" class="outline-4">
<h4 id="org4c3775c"><span class="section-number-4">5.7.2</span> Modified goals - everything only applies to non-faulty nodes</h4>
</div>
<div id="outline-container-orgea28da3" class="outline-4">
<h4 id="orgea28da3"><span class="section-number-4">5.7.3</span> A simple (unsuccessful) attempt</h4>
<div class="outline-text-4" id="text-5-7-3">
<ol class="org-ol">
<li><p>
(Byzantine fault) A tells B 1, A tells C 0.
B tells everyone 1.
C tells everyone 0.
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">node</th>
<th scope="col" class="org-left">received</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">A</td>
<td class="org-left">1, 1, 0</td>
</tr>

<tr>
<td class="org-left">B</td>
<td class="org-left">1, 1, 0</td>
</tr>

<tr>
<td class="org-left">C</td>
<td class="org-left">0, 1, 0</td>
</tr>
</tbody>
</table></li>
<li>Anyone could be lying. C decides B is lying -&gt; it decides on 0. Similarly, B
will decide on 1, violating Agreement.</li>
<li>Furthermore, if you cross-check, you are not sure if the person you
cross-check with is reliable.</li>
</ol>
</div>
</div>
<div id="outline-container-org8d3a11e" class="outline-4">
<h4 id="org8d3a11e"><span class="section-number-4">5.7.4</span> Theorem: Byzantine Consensus Threshold</h4>
<div class="outline-text-4" id="text-5-7-4">
<ul class="org-ul">
<li>Theorem: if number of processes <code>n</code>, number of byzantine failures <code>f</code>, if
<code>n&lt;=3f</code>, then any protocol cannot reach consensus.</li>
<li>Proof: omitted.</li>
</ul>
</div>
</div>
<div id="outline-container-orgadd4419" class="outline-4">
<h4 id="orgadd4419"><span class="section-number-4">5.7.5</span> A protocol for # nodes n &gt;= 4f+1</h4>
<div class="outline-text-4" id="text-5-7-5">
</div>
<ol class="org-ol">
<li><a id="org86dfc78"></a>Definitions<br />
<div class="outline-text-5" id="text-5-7-5-1">
<ul class="org-ul">
<li>We have <i>phases</i>.</li>
<li>Each phase has a <i>coordinator</i> which sends a proposal to all processes.</li>
<li>If everyone decides, we have an agreement.</li>
<li>A phase is a <i>deciding phase</i> if the coordinator is nonfaulty.</li>
<li>Each phase has a 3 rounds: broadcast, coordinator, decision.</li>
</ul>
</div>
</li>
<li><a id="org81712c0"></a>Protocol<br />
<div class="outline-text-5" id="text-5-7-5-2">
<ol class="org-ol">
<li>Setup: maintain everyone&rsquo;s value initialized to 0, my value = my input.</li>
<li>Repeat the following steps (called a phase) for <code>f+1</code> times:
<ol class="org-ol">
<li>Round 1: all-to-all broadcast. Send my input to everyone (including
myself). Record all msg received (if msg is non-binary or null, set it to
0). If there is a majority (occurrence &gt; n/2) value, let <code>proposal</code> be that
value, otherwise <code>proposal</code> is 0.</li>
<li>Round 2: coordinator. if I am the coordinator (the ith phase has the ith node as
coord), send proposal to all, otherwise receive a proposal.</li>
<li>Round 3: if there is an overwhelming majority in V (already determined in
R1), ie &gt; n/2 + f, set my value to that majority value, otherwise set it
to the proposal.</li>
</ol></li>
<li>After phases end, conclude with my value.</li>
</ol>
</div>
</li>
<li><a id="org95a4fa0"></a>Correctness - invariance for every round<br />
<ol class="org-ol">
<li><a id="org7f0918e"></a>Lemma 1: all non-faulty processes retain <code>y</code> if all their values are <code>y</code><br />
<div class="outline-text-6" id="text-5-7-5-3-1">
<p>
Since \(n \ge 4f+1\), we must have \(n-f \ge 3f+1 \ge (4f + 1)/2 + f = n/2 + f\).
This means the non-faulty nodes must be a overwhelming majority. Suppose they
all have the same value at the start of phase <code>k</code>, they must retain these values
at end of phase <code>k</code> forced by round 3.
</p>
</div>
</li>
<li><a id="org707745a"></a>Lemma 2: if coord is nonfaulty, then all nonfaulty processes have the same value after a round k.<br />
<div class="outline-text-6" id="text-5-7-5-3-2">
<p>
The coordinator can propose two values:
</p>
<ol class="org-ol">
<li>Proposes some <code>x</code>. <code>x</code> occurs MORE THAN <code>n/2</code> times on coordinator process.
Worst case, <code>f</code> out of <code>n/2</code> are faulty. These MORE THAN <code>n/2-f</code> non-faulty
nodes must broadcast exactly these values to others, thus on any other nodes,
they cannot have another value <code>y</code> having the overwhelming majority (<code>y</code> can
only have LESS THAN <code>n/2+f</code> votes) in R3 and can thus only accept the
proposal.</li>
<li>Proposes 0. This means out of all the values coord sees, none exceed <code>n/2</code>.
It means none of these values will reach overwhelming majority MORE THAN
<code>n/2+f</code> since the amount can differ by atmost f.</li>
</ol>
</div>
</li>
<li><a id="org6cfc21c"></a>Termination - we let there be f+1 phases. No wait =&gt; termination.<br /></li>
<li><a id="org8a863ed"></a>Validity - by lemma 1, the invariance make them decide its input.<br /></li>
<li><a id="orgea99c31"></a>Agreement<br />
<div class="outline-text-6" id="text-5-7-5-3-5">
<ul class="org-ul">
<li><code>f+1</code> phases means at least one good phase.</li>
<li>The one good phase triggers lemma 2.</li>
<li>Lemma 2 triggers lemma 1, agreeing on the value as per lemma 1.</li>
</ul>
</div>
</li>
</ol>
</li>
</ol>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Tan Yee Jian</p>
<p class="date">Created: 2021-04-30 Fri 16:59</p>
</div>
</body>
</html>
