#+TITLE: Cs4231

* Arrows
- $a\prec b$ is process order.
- $a\to b$ is happen-before order: the logical clock value is less than, iff
  there is a directed path. Clearly $a\prec b\implies a\to b$.
- $a\leadsto b$ There is also send-receive order.
* Lecture 5 Global Snapshot
Assumption: channels are FIFO. If not, it is discussed in Message Ordering
lecture
** Definitions
*** Global snapshot
A set of events =E= such that for any event =e= in =E=, if $f\prec e$, then
$f\in E$.
*** Consistent global snapshot
A global snapshot where if $e_1$ send, $e_2$ receive, $e_2$ in then $e_1$ must be in.
** Chandy & Lamport's protocal for taking snapshots
- Key idea:
  1. after a process takes a snapshot, it orders others to stop via a message
  2. If they already took a snapshot before the order arrives, then capture all
     message till the order (these are the on-the-fly messages)
  3. Otherwise once they receive the order, stop. (otherwise will receive stuff
     which sender does not include)
* Lecture 6 Message Ordering
We still assume FIFO (except for fully async order) for inter-process channels.
** Definitions
*** Fully Asynchronous
No restriction.
*** FIFO
Messages $s_1,s_2$ are sent from i to j. Then $\neg(s_2\prec s_1)$.
*** Causally Ordered
If $s_1$ happen before $s_2$, $r_1, r_2$ on the same process, then $r_1\prec
r_2$.
*** Synchronous Ordered
Diagram can be redrawn into vertical, respecting happen-before, process and
send-receive order.
** Algorithm to ensure Causal Ordering
*** Core Idea
When a process sends a message, attach also every message you have seen or sent
so far.
*** Why does it work?
- Recall causal ordering: if s1 happens before s2 (there is a directed path),
  then r1 must before r2
- If s1 and s2 are on the same process, then attaching all messages it has sent
  will include s1 for the target process to see before s2
- If not on the same process, then attaching all messages it has received will
  include s1 for the target process to see before s2.
*** Can we improve it?
- Just include messages that are targeted at the receiving process.
- Or number each message locally on the process. Instead of attaching all
  messages, make the target wait until all processes' intended message to it has
  been delivered.
** Skeen's Algorithm for Broadcast Ordering
- An example is a chat group, sending messages to everyone
- Everyone needs the same message number for the same msg
*** Core Idea
1. First round - send message to everyone to save in the buffer. After saving,
   each process replies the coordinator their current logical clock number.
2. Wait for all them to come back, and assign the message the largest logical
   clock number.
3. Let everyone know the decided message number.
*** Summary
It orders messages, not logical clock numbers. Each logical clock value run as
usual.
* Leader Election
** Chang-Roberts Algorithm for Leader Election
*** Setting
Given a ring of nodes that can only send messages clockwise, select a leader
*** Algorithm
1. Sending: Every node send its number clockwise
2. Receiving: Every node relay the message (clockwise) if the value is bigger
   than self.
3. If receive own id, then it is the leader
*** Complexity
**** Message Complexity
Number of messages sent
**** Best Case
Condition: sorted in clockwise ascending
1+...+1+n = 2n-1
**** Worst case
Condition: sorted in clockwise descending
1 + 2 + ... + n = n(n+1)/2
**** Average case?
* Lecture 8 Consensus
** Timing Models
*** Synchronous
Bounded amount of time to do processing, and bounded amount of time to send
messages
** Version 0: No failure
*** Algorithm
For any process:
1. Keep broadcasting own value
2. Once confident have all messages (due to known ub), run a deterministic
   algorithm on all values (eg. max/min)
** TODO Version 1:
** Version 2: Consensus with Link Failures (Synchronous)
*** Setup
- nodes do not fail
- but the message channels (between any pair of processes) can fail arbitrarily
  long (drop unbounded # of messages)
*** Goal 1: Termination, Agreement, Validity
- Termination: all nodes eventually decide
- Agreement: all nodes settle on one same value
- Validity: if all started as same value, must settle on that value.
**** TODO There is no deterministic algorithm
1. Suppose there is one. Two processes with a eternally failing channel
*** Goal 2: T, A, Weakened Validity
- If all start from 0, should settle on 0
- If all start from 1, then must settle on 1 only if no message is lost
**** TODO Still no deterministic algorithm.
- Lemma: if two processes start with 1, and one process's last message is lost,
  none detects it. Then the one who lost, B, didn't know it lost, hence is
  *indistinguishable* from nothing is lost and must settle on 1. By agreement, A
  should settle on 1 as well.
- But we can still chain indistinguishability from 0, 0 to 1, 1 and force a
  contradiction (settle on 0, 0 given 1, 1, when all messages are lost)
*** Goal 3: T, Limited Agreement, Weakened Validity
- Limited Agreement: all nodes decide on the same value with probability =
  (1-\epsilon)
**** Randomized Algorithm that works
1. Setup: P1, P2, where P1 sets the # of rounds (called *bar*) randomly. Each
   process has an *input*, 0 or 1. Each process has a value called *level*,
   initialized to 0.
2. Send messages and receive messages for r rounds. Each message contain bar (if
   you know it), input, and its level. Upon receive, update own level: =my_level
   = their_level + 1=.
3. We can inductively show that every pair of levels must differ by at most one
   at every round.
4. Once r rounds are over, decide on 1 IFF you know that everyone has input 1
   AND you know bar (trivial for P1) AND level >= bar.
***** Analysis
****** TODO Errors
Error only happens if P1 decide on 1 while P2 decide on 0 (WLOG).
******* Case 1: P1 does not receive from P2 at all, but P2 does
- Then L1 = 0 (does not receive) and L2 = 1 (received at least 1)
- P1 must not know P2's input and hence output 0, and error only occurs if P2
  output 1 IFF L2 = 1 >= bar (is a postive value) = 1.

******* Case 1: P1 does not receive from P2 at all, but P2 does
- Then L1 = 0 (does not receive) and L2 = 1 (received at least 1)
- P1 must not know P2's input and hence output 0, and error only occurs if P2
  output 1 IFF L2 = 1 >= bar (is a postive value) = 1.
** Version 3: Node crash failures (Asynchronous)
*** Setup
- Nodes can crash (indefinitely), but channels are reliable
- Asynchronous: message delay is unbounded
- Impact: can no longer define a round
*** Fischer-Lynch-Paterson (FLP) Impossibility Theorem
Statement: the distributed consensus problem under the asynchronous timing model
is impossible to solve, even with a *single* node crash failure.
- Fundamental reason: the protocol is unable to accurately detect node failure.
